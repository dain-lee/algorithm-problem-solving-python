'''
'탐욕법' - 현재 상황에서 지금 당장 좋은 것만 고르는 방법
매 순간 가장 좋아 보이는 것을 선택하며, 현재의 선택이 나중에 미칠 영향에 대해서는 고려하지 않음
문제에서 '가장 큰 순서대로', '가장 작은 순서대로'와 같은 기준을 제시
대체로 이 기준은 정렬 알고리즘을 사용했을 때 만족시킬 수 있으므로 그리디 알고리즘 문제는 자주 정렬 알고리즘과 짝을 이뤄 출제됨
'''

# 예제 1 - 거스름돈
'''
당신은 음식점의 계산을 도와주는 점원이다.
카운터에는 거스름돈으로 사용할 500원, 100원, 50원, 10원짜리 동전이 무한히 존재한다고 가정한다.
손님에게 거슬러 줘야 할 돈이 N원일 때 거슬러 줘야 할 동전의 최소 개수를 구하라.
단, 거슬러 줘야 할 돈 N은 항상 10의 배수이다.
'''

'''
'가장 큰 화폐 단위부터' 거슬러 줌
N원을 거슬러 줘야 할 때, 가장 먼저 500원으로 거슬러 줄 수 있을 만큼 거슬러 주고
그다음 100원, 50원, 10원짜리 동전을 차례대로 거슬러 줄 수 있을 만큼 거슬러 주면
최소의 동전 개수로 모두 거슬러 줄 수 있음
'''

# 거슬러 줘야 할 돈이 1260원일 경우
n = 1260
count = 0

# 큰 단위의 화폐부터 차례대로 확인
coin_types = [500, 100, 50, 10]

for coin in coin_types:
    count += n / coin
    n %= coin

print(count)

'''
대부분의 문제는 그리디 알고리즘을 이용했을 때 '최적의 해'를 찾을 수 없을 가능성이 다분
따라서 그리디 알고리즘으로 문제의 해법을 찾았을 때는 그 해법이 정당한지 검토해야 함
거스름돈 문제를 그리디 알고리즘으로 해결할 수 있는 이유는
가지고 있는 동전 중에서 큰 단위가 항상 작은 단위의 배수이므로 작은 단위의 동전들을 종합해 다른 해가 나올 수 없기 때문
예를 들어 800원을 거슬러 줘야 하는데, 화폐단위가 500원, 400원, 100원인 경우
그리디 알고리즘으로는 4개의 동전 (500 + 100 + 100 + 100)을 거슬러 줘야 하지만, 최적의 해는 2개의 동전 (400 + 400)
'''