# 경쟁적 전염
# 난이도 중 | 풀이 시간 50분 | 시간 제한 1초 | 메모리 제한 256MB

'''
NxN 크기의 시험관이 있습니다.
시험관은 1x1 크기의 칸으로 나누어지며, 특정한 위치에는 바이러스가 존재할 수 있습니다.
모든 바이러스는 1번부터 K번까지의 바이러스 종류 중 하나에 속합니다.
시험관에 존재하는 모든 바이러스는 1초마다 상, 하, 좌, 우의 방향으로 증식하는데, 매 초마다 번호가 낮은 종류의 바이러스부터 먼저 증식합니다.
또한 증식 과정에서 특정한 칸에 이미 어떠한 바이러스가 존재한다면, 그 곳에는 다른 바이러스가 들어갈 수 없습니다.
시험관의 크기와 바이러스의 위치 정보가 주어졌을 때, S초가 지난 후에 (X,Y)에 존재하는 바이러스의 종류를 출력하는 프로그램을 작성하세요.
만약 S초가 지난 후에 해당 위치에 바이러스가 존재하지 않는다면, 0을 출력합니다.
이 때 X와 Y는 각각 행과 열의 위치를 의미하며, 시험관의 가장 왼쪽 위에 해당하는 곳은 (1,1)에 해당합니다.

예를 들어 다음과 같이 3x3 크기의 시험관에 서로 다른 1번, 2번, 3번 바이러스가 각각 (1,1), (1,3), (3,1)에 위치해 있을 때 2초가 지난 뒤에 (3,2)에 존재하는 바이러스의 종류를 계산해보겠습니다.
1 0 2
0 0 0
3 0 0

1초가 지난 후에 시험관의 상태는 다음과 같습니다.
1 1 2
1 0 2
3 3 0

2초가 지난 후에 시험관의 상태는 다음과 같습니다.
1 1 2
1 1 2
3 3 2

결과적으로 2초가 지난 뒤에 (3, 2)에 존재하는 바이러스의 종류는 3번 바이러스입니다.
따라서 3을 출력하면 정답입니다.
'''

'''
입력 조건
- 첫째 줄에 자연수 N, K가 주어지며, 각 자연수는 공백으로 구분합니다. (1 <= N <= 200, 1 <= K <= 1,000)
- 둘째 줄부터 N개의 줄에 걸쳐서 시험관의 정보가 주어집니다. 각 행은 N개의 원소로 구성되며, 해당 위치에 존재하는 바이러스의 번호가 주어지며 공백으로 구분합니다.
- 단, 해당 위치에 바이러스가 존재하지 않는 경우 0이 주어집니다. 또한 모든 바이러스의 번호는 K 이하의 자연수로만 주어집니다.
- N + 2번째 줄에는 S, X, Y가 주어지며 공백으로 구분합니다. (0 <= S <= 10,000, 1 <= X, Y <= N)

출력 조건
- S초 뒤에 (X, Y)에 존재하는 바이러스의 종류를 출력합니다. 만약 S초 뒤에 해당 위치에 바이러스가 존재하지 않는다면, 0을 출력합니다.
'''

'''
너비 우선 탐색을 이용하여 해결
다만, 각 바이러스가 낮은 번호부터 증식해야 하므로, 초기에 큐에 원소를 삽입할 때 낮은 바이러스의 번호부터 삽입해야 함
'''

from collections import deque

n, k = map(int, input().split())
graph = [list(map(int, input().split())) for _ in range(n)]
s, x, y = map(int, input().split())

dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]

def bfs(graph):
    # 바이러스가 존재하는 경우 data 배열에 (바이러스 종류, x, y, 시간) 삽입
    data = []
    for i in range(n):
        for j in range(n):
            if graph[i][j]:
                data.append((graph[i][j], i, j, 0))
    
    # 바이러스 종류를 기준으로 정렬 후 큐에 삽입
    data.sort()
    queue = deque(data)

    while queue:
        virus, x, y, t = queue.popleft()
        # s초가 지나거나, 큐가 빌 때까지 반복
        if t == s:
            return True
        # 상하좌우 확인
        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]
            if nx < 0 or nx >= n or ny < 0 or ny >= n:
                continue
            # 아직 방문하지 않은 위치라면, 그 위치에 바이러스 넣기
            if graph[nx][ny] == 0:
                graph[nx][ny] = virus
                queue.append((virus, nx, ny, t+1))

bfs(graph)

print(graph[x-1][y-1])