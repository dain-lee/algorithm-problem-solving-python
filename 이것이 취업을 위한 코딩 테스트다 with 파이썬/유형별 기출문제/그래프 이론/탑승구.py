# 탑승구
# 난이도 중 | 풀이 시간 50분 | 시간 제한 1초 | 메모리 제한 128MB

'''
공항에는 G개의 탑승구가 있으며, 각각의 탑승구는 1번부터 G번까지의 번호로 구분됩니다.
공항에는 P개의 비행기가 차례대로 도착할 예정이며, i번째 비행기를 1번부터 g(i)번째(1 <= g(i) <= G) 탑승구 중 하나에 영구적으로 도킹해야 합니다.
이때, 다른 비행기가 도킹하지 않은 탑승구에만 도킹할 수 있습니다.
또한 P개의 비행기를 순서대로 도킹하다가 만약에 어떠한 탑승구에도 도킹할 수 없는 비행기가 나오는 경우, 그 시점에서 공항의 운행을 중지합니다.
공항의 관리자는 최대한 많은 비행기를 공항에 도킹하고자 합니다.
비행기를 최대 몇 대 도킹할 수 있는지를 출력하는 프로그램을 작성하세요.
'''

'''
입력 조건
- 첫째 줄에는 탑승구의 수 G(1 <= G <= 100,000)가 주어집니다.
- 둘째 줄에는 비행기의 수 P(1 <= P <= 100,000)가 주어집니다.
- 다음 P개의 줄에는 각 비행기가 도킹할 수 있는 탑승구의 정보 g(i)(1 <= g(i) <= G)가 주어집니다. 이는 i번째 비행기가 1번부터 g(i)번째(1 <= g(i) <= G) 탑승구 중 하나에 도킹할 수 있다는 의미입니다.

출력 조건
- 첫째 줄에 도킹할 수 있는 비행기의 최대 개수를 출력합니다.
'''

'''
서로소 집합 알고리즘을 이용해서 해결
각 탑승구를 서로 다른 집합으로 나타낸 후, 초기 상태는 모두 루트 노드로 자기 자신을 가리키고 있다고 가정 (문제 해결을 위해 0번 탑승구도 존재한다고 생각)
비행기가 순서대로 들어오면 차례대로 도킹을 수행해야 하는데, 가능한 큰 번호의 탑승구로 도킹을 수행한다고 가정
이때, 새롭게 비행기가 도킹이 되면, 해당 집합을 바로 왼쪽에 있는 집합과 합침 -> 해당 비행기를 g(i)의 루트 노드에 해당하는 탑승구에 도킹한 후, 루트 노드를 1 줄여준다는 뜻
가능한 큰 번호의 탑승구로 도킹을 수행하므로, g(i)가 4인 비행기를 4번 탑승구에 도킹했으면, g(i)가 같은 그 다음 비행기는 3번 탑승구에 도킹해야 하기 때문
새로운 비행기를 도킹할 때 g(i)의 루트 노드가 0이면 1부터 g(i)번째까지의 탑승구가 모두 차있다는 뜻이므로 도킹을 할 수 없음 -> 공항 운행 중지

parent 배열에 g(i)일 때 들어갈 수 있는 탑승구 번호를 저장, 부모 노드가 루트 노드가 아니면 거슬러 올라가서 루트 노드를 찾음 => 서로소 집합 알고리즘
'''

def find_parent(parent, x):
    if parent[x] != x:
        parent[x] = find_parent(parent, parent[x])
    return parent[x]

def union_parent(parent, a, b):
    a = find_parent(parent, a)
    b = find_parent(parent, b)
    if a < b:
        parent[b] = a
    else:
        parent[a] = b

g = int(input())
p = int(input())
parent = [i for i in range(g + 1)]
gi = [int(input()) for _ in range(p)]

result = 0
for i in range(p):
    x = gi[i]
    gate = find_parent(parent, x)
    if gate == 0: # 현재 노드의 루트 노드가 0이라면, 종료
        break
    else:
        result += 1
        union_parent(parent, gate-1, gate) # 그렇지 않다면 바로 왼쪽의 집합과 합치기

print(result)
